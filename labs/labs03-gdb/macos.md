## แกะรหัส C ด้วย LLDB: คู่มือทีละขั้นตอนกับไฟล์ `main.c`

บทเรียนนี้จะสอนการใช้ LLDB ในการ debug โค้ด C ที่อยู่ในไฟล์ชื่อ `main.c` โดยจะเน้นไปที่การตรวจสอบค่าตัวแปร,
การแสดงผลลัพธ์, และการใช้ breakpoint เพื่อทำความเข้าใจการทำงานของภาษา C อย่างละเอียด

ไฟล์ `main.c` จะแสดงให้เห็นถึงการใช้งานตัวดำเนินการเพิ่มค่า (`++`) ในภาษา C โดยจะมีการประกาศตัวแปร integer
จำนวน 4 ตัว (`a`, `b`, `c`, `d`) และแสดงให้เห็นถึงผลลัพธ์ของการดำเนินการ `++` ในรูปแบบต่างๆ

## Starting Debugging with GDB

**1. Writing the Code**

- **Private Computer (MacOS)**: สามารถก็อบคำสั่งด้านล่างไปใส่ใน Terminal ได้เลย
  โดยที่คำสั่งนี้จะสร้างโฟลเดอร์ `PhysicalCom` ที่ Desktop และสร้างไฟล์ให้อัตโนมัติ
  ```bash
  mkdir -p ~/Desktop/PhysicalCom
  curl -o ~/Desktop/PhysicalCom/main.c "https://raw.githubusercontent.com/TaeTanakrit0089/PhysicalComputing-167/main/labs/labs03-gdb/files/main.c"
  ```
  ให้ลองเปิดไฟล์ที่สร้างขึ้นมาใหม่ดู ข้างในไฟล์ต้องมีโค้ดดังนี้:

   ```c
   #include "stdio.h"
   
   int main() {
       int a = 10, b = 20, c = 30, d = 40;
   
       d = a++ + b++ + c++;
       d = ++a + ++b + ++c;
   
       printf("Hello, IT-KMITL");
   
       a = a++ + ++d;
       c = ++a + ++c;
   
       return 0;
   }
   ```

**ขั้นตอน:**

1. **คอมไพล์โค้ด:**

   ก่อนเริ่ม debug ต้องคอมไพล์ไฟล์ `main.c` ด้วย Clang โดยเพิ่ม option `-g` ดังนี้:

   ```bash
   clang -g main.c -o main
   # หรือ
   gcc -g main.c -o main
   ```

    - `-g` บอกคอมไพเลอร์ให้สร้างข้อมูลสำหรับ debugging
    - `-o <ชื่อไฟล์>` บอกคอมไพเลอร์ให้สร้างไฟล์ output เป็น `<ชื่อไฟล์>`

2. **เริ่มต้น Debugger:**

   หลังจากคอมไพล์เสร็จแล้ว จะได้ไฟล์ชื่อ `main`  
   เริ่มต้นการ debug โดยพิมพ์ `lldb` ตามด้วยชื่อไฟล์:

   ```bash
   lldb main
   ```
   LLDB จะถูกเรียกใช้งานและพร้อมรับคำสั่ง

   ใช้คำสั่ง `list` เพื่อแสดงโค้ดรอบๆ บรรทัดปัจจุบัน
   คำสั่ง list มีรูปแบบดังนี้
    - `list`: แสดงโค้ด 10 บรรทัด รอบๆ บรรทัดปัจจุบัน, หากใช้ `list` ซ้ำ LLDB จะแสดงโค้ด 10 บรรทัดถัดไป
    - `list <หมายเลขบรรทัด>`: แสดงโค้ด 10 บรรทัด รอบๆ บรรทัดที่ `<หมายเลขบรรทัด>`
    - `list <ชื่อฟังก์ชัน>`: แสดงโค้ดของฟังก์ชัน `<ชื่อฟังก์ชัน>`
    - `list -`: แสดงโค้ด 10 บรรทัด ก่อนหน้ากลุ่มบรรทัดที่แสดงล่าสุด

   ลองใช้คำสั่ง `list`
   ```lldb
   (lldb) list 1
   ```

   ในโค้ดตัวอย่าง main.c มี 15 บรรทัด การรัน `list` ครั้งแรกจะแสดงโค้ด 10 บรรทัดแรก
   และการรันครั้งที่สองจะแสดงโค้ดที่เหลือ
   หากรัน `list` อีกครั้งจะพบ error
   เนื่องจากได้แสดงโค้ดทั้งหมดไปแล้ว
   การแก้ไขคือการระบุ Argument เพิ่มเติมให้กับคำสั่ง `list <หมายเลขบรรทัด>`
   โดยให้ `<หมายเลขบรรทัด>` เป็นเลข 1 หมายถึงเริ่มต้นแสดงโค้ดใหม่ตั้งแต่บรรทัดที่ 1
   ```lldb
   (lldb) list 1
   ```

3. **ตั้ง Breakpoint:**

   Breakpoint เป็นจุดที่เรากำหนดให้โปรแกรมหยุดทำงานชั่วคราว

   ใช้คำสั่ง `breakpoint set` หรือ `b` เพื่อตั้ง breakpoint โดยมี Syntax ดังนี้
   ```lldb
   breakpoint set --<OPTION> <LOCATION>
   ```
   หรือ
   ```lldb
   b <LOCATION>
   ```
   โดย `<LOCATION>` สามารถเป็น:
    * **ชื่อฟังก์ชัน:** LLDB จะหยุดโปรแกรมเมื่อเรียกใช้ฟังก์ชันนั้น เช่น `b main`
    * **หมายเลขบรรทัด:** LLDB จะหยุดโปรแกรมเมื่อทำงานถึงบรรทัดนั้น เช่น `b 10`
    * **ที่อยู่หน่วยความจำ:** LLDB จะหยุดโปรแกรมเมื่อเข้าถึงที่อยู่นั้น
    * **เงื่อนไข:** LLDB จะหยุดโปรแกรมเมื่อเงื่อนไขเป็นจริง เช่น `b main if i == 10`

   ให้ลองพิมพ์คำสั่งเพื่อสร้าง breakpoint ที่บรรทัดที่ 6 และ 11

   ```lldb
   (lldb) b 6
   (lldb) b 11
   ```
   เมื่อสร้าง breakpoint แล้ว สามารถตรวจสอบ breakpoint ทั้งหมดได้ด้วยคำสั่ง `breakpoint list` หรือ `br l`
   คำสั่งนี้จะแสดงรายการ breakpoint ที่ตั้งค่าไว้ในโปรแกรม
   ข้อมูลที่แสดงประกอบด้วย:

    * **Breakpoint ID:** หมายเลขประจำ breakpoint
    * **Type:** ประเภทของ breakpoint (เช่น breakpoint, watchpoint)
    * **Disposition:** สถานะหลังจาก breakpoint ถูกกระตุ้น (เช่น keep: เก็บ breakpoint ไว้, delete: ลบ breakpoint)
    * **Enabled:** สถานะของ breakpoint ว่าทำงานอยู่หรือไม่ (yes/no)
    * **Address:** ที่อยู่ของ breakpoint ในหน่วยความจำ
    * **What:** ข้อมูลระบุตำแหน่งของ breakpoint เช่น ชื่อไฟล์และหมายเลขบรรทัด

   ```lldb
   (lldb) breakpoint list
   ```
   การลบ Breakpoint ใช้คำสั่ง `breakpoint delete` หรือ `br de`  ตามด้วยหมายเลข breakpoint
   ```lldb
   (lldb) breakpoint delete <หมายเลข breakpoint>
   ```

4. **รันโปรแกรม:**

   เริ่มต้นการทำงานของโปรแกรมโดยใช้คำสั่ง `run` หรือ `r`:

   ```lldb
   (lldb) run
   ```

   โปรแกรมจะทำงานจนกระทั่งถึง breakpoint แรก (บรรทัดที่ 6)
   จากนั้นจะหยุดทำงานชั่วคราวและรอรับคำสั่ง debug

5. **ตรวจสอบค่าตัวแปร:**

   ใช้คำสั่ง `print` หรือ `p` เพื่อแสดงค่าของตัวแปร:

   ```lldb
   (lldb) print a
   (lldb) print b
   (lldb) print c
   (lldb) print d
   ```

   คำสั่งข้างต้นจะแสดงผลลัพธ์ของค่าตัวแปร a, b, c และ d ตามลำดับ
   ผลลัพธ์ที่ได้

   นอกจากการ print ตัวแปรทีละตัวแล้ว ยังสามารถใช้คำสั่ง `frame variable` หรือ `fr v`
   เพื่อดูภาพรวมของตัวแปร local ทั้งหมดภายในฟังก์ชันที่กำลังทำงานอยู่ได้อย่างรวดเร็ว

   ```lldb
   (lldb) frame variable
   ```

   ใช้คำสั่ง `list` เพื่อแสดงโค้ดรอบๆ บรรทัดปัจจุบัน
   ```lldb
   (lldb) list
   ```
6. **เรียกใช้โค้ดทีละบรรทัด:**

   คำสั่งต่อไปนี้ใช้สำหรับการ Debug แบบทีละขั้นตอน:

    - `next` หรือ `n`
        - **การทำงาน:** สั่งให้โปรแกรมทำงานบรรทัดถัดไป โดย***ไม่***เข้าไปในฟังก์ชันที่ถูกเรียกใช้งาน
        - **ตัวอย่าง:** หากบรรทัดปัจจุบันมีการเรียกใช้ฟังก์ชัน `calculate()` คำสั่ง next
          จะทำงานจนจบฟังก์ชัน `calculate()` และหยุดที่บรรทัดถัดไปหลังจากนั้น
    - `step` หรือ `s`
        - ดำเนินการโปรแกรมไปยังบรรทัดถัดไป โดย***เข้าไป***ภายในฟังก์ชันที่ถูกเรียกใช้
        - หากบรรทัดปัจจุบันมีการเรียกใช้ฟังก์ชัน `calculate()` จะหยุดที่บรรทัดแรกภายในฟังก์ชันนั้นๆ
    - `continue` หรือ `c`
        - สั่งให้โปรแกรมทำงานต่อเนื่อง จนกว่าจะพบ breakpoint หรือสิ้นสุดการทำงาน
    - `finish` หรือ `fin`
        - สั่งให้โปรแกรมทำงานต่อจนกว่าจะจบฟังก์ชันปัจจุบัน แล้วหยุดที่บรรทัดถัดไปหลังจากที่เรียกใช้ฟังก์ชันนั้น
          เหมาะสำหรับเมื่อต้องการออกจากฟังก์ชันปัจจุบันอย่างรวดเร็ว

   | คำสั่ง     | การทำงาน                                        | เหมาะสำหรับ                                                          |
         |------------|-------------------------------------------------|----------------------------------------------------------------------|
   | `next`/`n` | ทำงานบรรทัดถัดไป ไม่เข้าไปในฟังก์ชัน            | ข้ามฟังก์ชันที่มั่นใจว่าถูกต้อง                                      |
   | `step`/`s` | ทำงานบรรทัดถัดไป เข้าไปในฟังก์ชันที่ถูกเรียกใช้ | ตรวจสอบการทำงานของฟังก์ชันอย่างละเอียด                               |
   | `continue`/`c` | ทำงานต่อเนื่องจนกว่าจะพบ breakpoint             | ผ่านโค้ดที่ไม่สนใจ, ไปยัง breakpoint ถัดไป                           |
   | `finish`/`fin`   | ทำงานต่อจนจบฟังก์ชันปัจจุบัน                    | ออกจากฟังก์ชันปัจจุบันอย่างรวดเร็ว เมื่อตรวจสอบส่วนที่เหลือเสร็จแล้ว |

   พิมพ์คำสั่ง `step` เพื่อรันบรรทัดต่อไปและลองตรวจสอบค่าของตัวแปรดู
   จะเห็นว่าค่าของตัวแปรได้เปลี่ยนแปลงจากบรรทัดที่ 6 มาต่อที่บรรทัดที่ 7

   ```lldb
   (lldb) step
   (lldb) print a
   (lldb) print b
   (lldb) print c
   (lldb) print d
   ```

   พิมพ์คำสั่ง `continue` เพื่อให้โปรแกรมทำงานต่อ

      ```lldb
      (lldb) continue
      ```

   โปรแกรมจะทำงานต่อจนถึง breakpoint ที่บรรทัดที่ 11 และหยุดทำงานอีกครั้ง


7. **เฝ้าดูตัวแปร:**

   คำสั่ง `watchpoint set variable` หรือ `wa s v` ใน LLDB
   เป็นเครื่องมือที่มีประโยชน์ในการตรวจสอบการเปลี่ยนแปลงของค่าในตัวแปรระหว่างการ Debugging
   ต่างจากคำสั่ง print ที่แสดงค่าของตัวแปร ณ จุดที่รันคำสั่งเท่านั้น

   `watchpoint set variable` จะคอยตรวจสอบตัวแปรที่เรากำหนดไว้ตลอดเวลา
   และจะ**หยุดการทำงานของโปรแกรมทันทีที่ค่าของตัวแปรนั้นเปลี่ยนแปลง**
   มี Syntax ดังนี้

   ```lldb
   watchpoint set variable <ชื่อตัวแปร>
   ```
   หรือ
   ```lldb
   wa s v <ชื่อตัวแปร>
   ```

   จากตัวอย่างข้างต้นที่หยุดโปรแกรมไว้ที่บรรทัดที่ 11
   ลองเฝ้าดูตัวแปร `a` โดยใช้คำสั่ง
   ```lldb
   (lldb) watchpoint set variable a
   ```

   คำสั่งนี้จะสร้าง Watchpoint ขึ้นมา
   สามารถตรวจสอบ Watchpoint ทั้งหมดได้จากคำสั่ง
   ```lldb
   (lldb) watchpoint list
   ```

   ลบ Watchpoint ด้วยคำสั่ง `watchpoint delete` หรือ `wa de` ร่วมกับหมายเลข watchpoint:
   `watchpoint delete <หมายเลข watchpoint>`

   หลังจากสร้าง Watchpoint แล้ว ลองใช้คำสั่ง `continue` และดูผลลัพธ์
   จะพบว่ามีข้อความใหม่แสดงค่าก่อนและหลังการทำงานของบรรทัดที่ 11

   ```
   Watchpoint 1 hit:
   old value: 12
   new value: 13
   Process 16414 stopped
   * thread #1, queue = 'com.apple.main-thread', stop reason = watchpoint 1
     frame #0: 0x0000000100003f4c main`main at main.c:11:15
     8   	
     9   	    printf("Hello, IT-KMITL");
     10  	
     -> 11  	    a = a++ + ++d;
     12  	    c = ++a + ++c;
     13  	
     14  	    return 0;
     Target 0: (main) stopped.
   ```

   การทำงานของคำสั่ง `continue` ด้านบนทำให้เกิดการเปลี่ยนแปลงค่าของตัวแปร `a` ที่โค้ด `a++` (เรียกใช้ค่า `a`
   ก่อนแล้วค่อยเพิ่มค่า +1)
   ทำให้โปรแกรมหยุดทำงานทันทีที่ค่า `a` ถูกเปลี่ยนแปลง
   หากรันคำสั่ง `continue` อีกครั้ง

   ```
   Watchpoint 1 hit:
   old value: 13
   new value: 79
   Process 16414 stopped
   * thread #1, queue = 'com.apple.main-thread', stop reason = watchpoint 1
     frame #0: 0x0000000100003f60 main`main at main.c:12:9
     9   	    printf("Hello, IT-KMITL");
     10  	
     11  	    a = a++ + ++d;
     -> 12  	    c = ++a + ++c;
     13  	
     14  	    return 0;
     15  	}
     Target 0: (main) stopped.
   ```

   ค่าของ `a` เปลี่ยนจาก 13 เป็น 79 เพราะถูกเปลี่ยนแปลงอีกครั้งที่โค้ด `a = a++ + ++d;` (`a = 13 + 66`)
   จึงทำให้โปรแกรมหยุดทำงาน

   ปกติแล้วหากรันคำสั่ง `continue` โปรแกรมจะทำงานไปเรื่อยๆ จนถึง breakpoint ถัดไป
   หรือทำงานจนจบโปรแกรม
   แต่เมื่อมีการตั้งค่า `watchpoint` แล้ว
   คำสั่ง `continue` จะทำงานจนกระทั่งค่าของตัวแปรที่เฝ้าดูถูกเปลี่ยนแปลง

   ลองสังเกตการเปลี่ยนแปลงของค่า `a` ไปเรื่อยๆ จนจบการทำงานของโปรแกรม
   เมื่อโปรแกรมทำงานเสร็จสิ้น จะปรากฏข้อความดังนี้

   ```
   Process 75487 exited with status = 0 (0x00000000) 
   ```

8. **ออกจาก Debugger:**

   พิมพ์คำสั่ง `quit` หรือ `q` เพื่อออกจาก LLDB:

   ```lldb
   (lldb) quit
   ``` 
